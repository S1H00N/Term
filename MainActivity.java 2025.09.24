package com.example.myapplication;

import android.Manifest;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.TimePickerDialog;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.provider.Settings;
import android.util.Log;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;
import android.location.Address; // import 추가
import android.location.Geocoder; // import 추가
import java.io.IOException; // import 추가
import java.util.List; // import 추가
import java.util.Locale; // import 추가

import androidx.activity.EdgeToEdge;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.graphics.Insets;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;

import com.google.android.gms.location.FusedLocationProviderClient;
import com.google.android.gms.location.LocationServices;

import java.util.Calendar;

import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;

public class MainActivity extends AppCompatActivity {

    private TextView weatherTextView;
    private FusedLocationProviderClient fusedLocationClient;

    // --- 코드 수정 1: Retrofit과 WeatherAPI 객체를 멤버 변수로 선언 ---
    // 이렇게 하면 앱이 실행되는 동안 한번만 생성하여 계속 재사용할 수 있습니다.
    // 날씨를 요청할 때마다 객체를 새로 만드는 낭비를 줄여줍니다.
    private WeatherAPI weatherAPI;

    private final ActivityResultLauncher<String> requestPermissionLauncher =
            registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -> {
                if (isGranted) {
                    getLastLocationAndGetWeather();
                } else {
                    Toast.makeText(this, "위치 권한이 거부되었습니다.", Toast.LENGTH_SHORT).show();
                }
            });

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        EdgeToEdge.enable(this);
        setContentView(R.layout.activity_main);
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -> {
            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);
            return insets;
        });

        // --- 코드 수정 2: onCreate에서 Retrofit과 WeatherAPI 객체를 한번만 생성 ---
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("https://api.openweathermap.org/data/2.5/")
                .addConverterFactory(GsonConverterFactory.create())
                .build();
        weatherAPI = retrofit.create(WeatherAPI.class);
        // -----------------------------------------------------------------

        weatherTextView = findViewById(R.id.weatherTextView);
        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this);

        checkLocationPermissionAndGetWeather();

        Button timePickerButton = findViewById(R.id.timePickerButton);
        timePickerButton.setOnClickListener(v -> {
            Calendar now = Calendar.getInstance();
            TimePickerDialog timePicker = new TimePickerDialog(
                    this,
                    (view, hourOfDay, minute) -> checkPermissionAndSetAlarm(hourOfDay, minute),
                    now.get(Calendar.HOUR_OF_DAY),
                    now.get(Calendar.MINUTE),
                    false
            );
            timePicker.show();
        });
    }

    private void checkLocationPermissionAndGetWeather() {
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
            getLastLocationAndGetWeather();
        } else {
            requestPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION);
        }
    }

    private void getLastLocationAndGetWeather() {
        try {
            fusedLocationClient.getLastLocation()
                    .addOnSuccessListener(this, location -> {
                        if (location != null) {
                            double latitude = location.getLatitude();
                            double longitude = location.getLongitude();

                            // ▼▼▼ Geocoder를 사용하여 좌표를 주소로 변환하는 부분 ▼▼▼
                            Geocoder geocoder = new Geocoder(this, Locale.KOREAN);
                            try {
                                // API 33 이상에서는 getFromLocation에 Listener를 전달해야 합니다.
                                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                                    geocoder.getFromLocation(latitude, longitude, 1, addresses -> {
                                        if (addresses != null && !addresses.isEmpty()) {
                                            // 보통 locality가 도시 이름(예: "서울특별시")에 해당합니다.
                                            String cityName = addresses.get(0).getLocality();
                                            if (cityName == null) { // locality가 null이면 adminArea(예: "경기도")를 사용
                                                cityName = addresses.get(0).getAdminArea();
                                            }
                                            getWeatherData(latitude, longitude, cityName);
                                        }
                                    });
                                } else {
                                    // API 33 미만 버전의 동기 방식
                                    List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                                    if (addresses != null && !addresses.isEmpty()) {
                                        String cityName = addresses.get(0).getLocality();
                                        if (cityName == null) {
                                            cityName = addresses.get(0).getAdminArea();
                                        }
                                        getWeatherData(latitude, longitude, cityName);
                                    }
                                }
                            } catch (IOException e) {
                                Log.e("GeocoderError", "주소 변환 실패", e);
                                // 주소 변환에 실패하면 API가 주는 이름이라도 사용하도록 fallback 처리
                                getWeatherData(latitude, longitude, null);
                            }
                            // ▲▲▲ 여기까지 ▲▲▲
                        } else {
                            weatherTextView.setText("위치 정보를 찾을 수 없습니다.");
                        }
                    });
        } catch (SecurityException e) {
            Log.e("LocationError", "위치 접근 중 보안 오류 발생", e);
        }
    }

    // getWeatherData 메소드가 한국어 도시 이름을 받도록 수정
    private void getWeatherData(double latitude, double longitude, String koreanCityName) {
        Log.d("WeatherData", "getWeatherData 호출: lat=" + latitude + ", lon=" + longitude);

        String apiKey = "e85abfe3c443a1aa63a55892f35b65b3";
        Call<WeatherResponse> call = weatherAPI.getCurrentWeatherByCoord(latitude, longitude, apiKey, "metric", "kr");

        call.enqueue(new Callback<WeatherResponse>() {
            @Override
            public void onResponse(Call<WeatherResponse> call, Response<WeatherResponse> response) {
                if (response.isSuccessful() && response.body() != null) {
                    WeatherResponse weatherResponse = response.body();
                    double temperature = weatherResponse.main.temp;
                    String weatherStatus = "";
                    if (weatherResponse.weather != null && !weatherResponse.weather.isEmpty()) {
                        weatherStatus = weatherResponse.weather.get(0).description;
                    }

                    // Geocoder로 받은 한국어 도시 이름을 우선적으로 사용
                    String finalCityName = (koreanCityName != null) ? koreanCityName : weatherResponse.name;
                    weatherTextView.setText(finalCityName + " " + temperature + "°C, " + weatherStatus);

                } else {
                    weatherTextView.setText("날씨 정보 가져오기 실패");
                    Log.e("WeatherError", "응답 에러: " + response.code());
                }
            }

            @Override
            public void onFailure(Call<WeatherResponse> call, Throwable t) {
                weatherTextView.setText("네트워크 오류");
                Log.e("WeatherError", "네트워크 실패: " + t.getMessage());
            }
        });
    }

    private void checkPermissionAndSetAlarm(int hourOfDay, int minute) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
            if (!alarmManager.canScheduleExactAlarms()) {
                Intent intent = new Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM);
                startActivity(intent);
            } else {
                setAlarm(hourOfDay, minute);
            }
        } else {
            setAlarm(hourOfDay, minute);
        }
    }

    private void setAlarm(int hourOfDay, int minute) {
        Calendar calendar = Calendar.getInstance();
        calendar.set(Calendar.HOUR_OF_DAY, hourOfDay);
        calendar.set(Calendar.MINUTE, minute);
        calendar.set(Calendar.SECOND, 0);

        if (calendar.before(Calendar.getInstance())) {
            calendar.add(Calendar.DATE, 1);
        }

        AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
        Intent intent = new Intent(this, AlarmReceiver.class);
        PendingIntent pendingIntent = PendingIntent.getBroadcast(this, 1, intent, PendingIntent.FLAG_IMMUTABLE);
        alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), pendingIntent);

        Toast.makeText(this, "알람이 " + hourOfDay + "시 " + minute + "분에 설정되었습니다.", Toast.LENGTH_SHORT).show();
        Log.d("MainActivity", "알람이 " + calendar.getTime() + "에 설정되었습니다.");
    }
}
